<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Communication - Eye-Blink Morse</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="communication.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .connection-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .connection-controls .btn {
                width: 100%;
                padding: 15px;
                font-size: 16px;
            }
            
            .device-info {
                font-size: 14px;
            }
            
            .morse-display {
                flex-direction: column;
            }
            
            .morse-section {
                margin-bottom: 20px;
            }
            
            .action-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            
            .manual-controls {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .morse-btn {
                padding: 15px;
                font-size: 18px;
            }
        }
        
        /* Connection type indicator */
        .connection-type {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            margin-left: 10px;
        }
        
        .connection-type.bluetooth {
            background: #3b82f6;
            color: white;
        }
        
        .connection-type.serial {
            background: #10b981;
            color: white;
        }
        
        .device-capabilities {
            margin-top: 10px;
            padding: 10px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 6px;
            font-size: 14px;
        }
        
        .bluetooth-instructions {
            margin-top: 15px;
            padding: 15px;
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid #10b981;
            border-radius: 0 6px 6px 0;
        }
        
        .bluetooth-instructions h4 {
            margin: 0 0 10px 0;
            color: #059669;
        }
        
        .bluetooth-instructions ol {
            margin: 0;
            padding-left: 20px;
        }
        
        .bluetooth-instructions li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <h2>üëÅÔ∏è Eye-Blink Morse</h2>
            </div>
            <div class="nav-menu">
                <a href="index.html" class="nav-link">Home</a>
                <a href="communication.html" class="nav-link active">Communication</a>
                <a href="messages.html" class="nav-link">Messages</a>
                <a href="settings.html" class="nav-link">Settings</a>
            </div>
        </div>
    </nav>

    <main class="container">
        <!-- Device Connection -->
        <section class="card">
            <div class="card-header">
                <h3>üîó Device Connection</h3>
                <div class="connection-status" id="connectionStatus">
                    <span class="status-indicator offline"></span>
                    <span id="statusText">Disconnected</span>
                    <span class="connection-type" id="connectionType" style="display: none;"></span>
                </div>
            </div>
            <div class="card-body">
                <div class="connection-controls">
                    <button class="btn btn-primary" id="connectSerialBtn">
                        <span>üîå</span> Connect Device
                    </button>
                    <button class="btn btn-danger" id="disconnectSerialBtn" disabled>
                        <span>‚ùå</span> Disconnect
                    </button>
                    <button class="btn btn-info" id="testBtn" disabled>
                        <span>üß™</span> Test Connection
                    </button>
                </div>
                
                <div class="device-capabilities" id="deviceCapabilities">
                    <strong>Available connections:</strong>
                    <div id="capabilityList">Detecting...</div>
                </div>
                
                <div class="device-info" id="deviceInfo" style="display: none;">
                    <p><strong>Device:</strong> <span id="portName">-</span></p>
                    <p><strong>Connection:</strong> <span id="connectionMethod">-</span></p>
                    <p><strong>Status:</strong> <span id="deviceStatusText">Ready</span></p>
                </div>
                
                <!-- Mobile Bluetooth Instructions -->
                <div class="bluetooth-instructions" id="bluetoothInstructions" style="display: none;">
                    <h4>üì± Mobile Bluetooth Connection</h4>
                    <ol>
                        <li>Make sure your ESP32 is powered on and running the Bluetooth code</li>
                        <li>On Android: Enable Bluetooth in device settings</li>
                        <li>Click "Connect Device" button above</li>
                        <li>Select "EyeBlink-ESP32" from the device list</li>
                        <li>If prompted for a pairing code, enter: <strong>1234</strong></li>
                        <li>Once connected, start blinking to send Morse code!</li>
                    </ol>
                    <p><strong>Note:</strong> On mobile, we use Web Bluetooth API instead of Serial. Your device name should appear as "EyeBlink-ESP32".</p>
                </div>
            </div>
        </section>

        <!-- Live Morse Input -->
        <section class="card">
            <div class="card-header">
                <h3>üëÅÔ∏è Live Morse Input</h3>
                <div class="live-status">
                    <span class="pulse-indicator" id="pulseIndicator"></span>
                    <span>Listening for blinks...</span>
                </div>
            </div>
            <div class="card-body">
                <div class="morse-display">
                    <div class="morse-section">
                        <label>Current Building Pattern</label>
                        <div class="morse-building" id="building">
                            <span class="building-text">‚Äî</span>
                            <span class="building-cursor"></span>
                        </div>
                        <div class="morse-raw" id="liveMorse">(waiting for input)</div>
                    </div>
                    <div class="morse-section">
                        <label>Decoded Text</label>
                        <div class="decoded-display" id="decoded" contenteditable="true"></div>
                        <div class="word-count">Words: <span id="wordCount">0</span> | Characters: <span id="charCount">0</span></div>
                    </div>
                </div>
                <div class="action-buttons">
                    <button class="btn btn-success" id="saveBtn">
                        <span>üíæ</span> Save Message
                    </button>
                    <button class="btn btn-info" id="translateBtn">
                        <span>üåê</span> Translate to Bangla
                    </button>
                    <button class="btn btn-secondary" id="speakBtn">
                        <span>üîä</span> Speak
                    </button>
                    <button class="btn btn-outline" id="clearBtn">
                        <span>üóëÔ∏è</span> Clear
                    </button>
                </div>
            </div>
        </section>

        <!-- Manual Morse Input -->
        <section class="card">
            <div class="card-header">
                <h3>‚å®Ô∏è Manual Morse Input</h3>
            </div>
            <div class="card-body">
                <div class="manual-input-section">
                    <label>Manual Pattern Input</label>
                    <div class="manual-display" id="manualBox" contenteditable="true"></div>
                    <div class="manual-controls">
                        <button class="morse-btn" data-ch=".">
                            <span class="morse-symbol">‚Ä¢</span>
                            <span class="morse-label">Dot</span>
                        </button>
                        <button class="morse-btn" data-ch="-">
                            <span class="morse-symbol">‚Äî</span>
                            <span class="morse-label">Dash</span>
                        </button>
                        <button class="morse-btn" data-ch=" ">
                            <span class="morse-symbol">‚ê£</span>
                            <span class="morse-label">Space</span>
                        </button>
                        <button class="morse-btn" data-ch="/">
                            <span class="morse-symbol">/</span>
                            <span class="morse-label">Word Sep</span>
                        </button>
                        <button class="btn btn-outline btn-sm" id="mClear">Clear</button>
                        <button class="btn btn-primary btn-sm" id="mSend">Add to Text</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Connection Troubleshooting -->
        <section class="card" id="troubleshootingCard" style="display: none;">
            <div class="card-header">
                <h3>üîß Connection Troubleshooting</h3>
            </div>
            <div class="card-body">
                <div class="troubleshooting-content">
                    <h4>Mobile (Android) Issues:</h4>
                    <ul>
                        <li>Make sure you're using Chrome browser (not Firefox or other browsers)</li>
                        <li>Enable Bluetooth in Android settings</li>
                        <li>Make sure your ESP32 is running the Bluetooth-enabled code</li>
                        <li>Try turning Bluetooth off and on again</li>
                        <li>Clear browser cache and reload the page</li>
                    </ul>
                    
                    <h4>Desktop Issues:</h4>
                    <ul>
                        <li>Close Arduino IDE Serial Monitor before connecting</li>
                        <li>Make sure ESP32 is connected via USB</li>
                        <li>Check that the correct COM port is available</li>
                        <li>Try a different USB cable or port</li>
                    </ul>
                    
                    <h4>General Tips:</h4>
                    <ul>
                        <li>Only one application can connect to the device at a time</li>
                        <li>If connection fails, try refreshing the page</li>
                        <li>Make sure your device is powered and running the correct firmware</li>
                    </ul>
                </div>
                <button class="btn btn-outline" onclick="document.getElementById('troubleshootingCard').style.display='none'">
                    Close Troubleshooting
                </button>
            </div>
        </section>

        <!-- Quick Reference -->
        <section class="card">
            <div class="card-header">
                <h3>üìö Quick Reference</h3>
                <div>
                    <button class="btn btn-outline btn-sm" id="toggleQuickRef">Show Chart</button>
                    <button class="btn btn-outline btn-sm" onclick="document.getElementById('troubleshootingCard').style.display='block'">
                        Troubleshooting
                    </button>
                </div>
            </div>
            <div class="card-body quick-ref" id="quickRefContent" style="display: none;">
                <div class="ref-grid">
                    <div class="ref-section">
                        <h4>Common Letters</h4>
                        <div class="ref-items">
                            <div class="ref-item"><code>‚Ä¢</code> = E</div>
                            <div class="ref-item"><code>‚Äî</code> = T</div>
                            <div class="ref-item"><code>‚Ä¢‚Ä¢</code> = I</div>
                            <div class="ref-item"><code>‚Ä¢‚Äî</code> = A</div>
                            <div class="ref-item"><code>‚Äî‚Ä¢</code> = N</div>
                            <div class="ref-item"><code>‚Ä¢‚Ä¢‚Ä¢ </code> = S</div>
                            <div class="ref-item"><code>‚Äî‚Ä¢‚Ä¢</code> = D</div>
                            <div class="ref-item"><code>‚Ä¢‚Ä¢‚Ä¢</code> = S</div>
                        </div>
                    </div>
                    <div class="ref-section">
                        <h4>Common Words</h4>
                        <div class="ref-items">
                            <div class="ref-item"><code>‚Äî ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ‚Ä¢</code> = THE</div>
                            <div class="ref-item"><code>‚Ä¢‚Äî ‚Äî‚Ä¢ ‚Ä¢‚Ä¢‚Ä¢ </code> = AND</div>
                            <div class="ref-item"><code>‚Äî‚Ä¢‚Äî ‚Äî‚Äî‚Äî ‚Ä¢‚Ä¢‚Äî</code> = YOU</div>
                            <div class="ref-item"><code>‚Ä¢‚Ä¢</code> = I</div>
                            <div class="ref-item"><code>‚Ä¢‚Äî ‚Ä¢</code> = AE (YES)</div>
                            <div class="ref-item"><code>‚Äî‚Ä¢ ‚Äî‚Äî‚Äî </code> = NO</div>
                        </div>
                    </div>
                    <div class="ref-section">
                        <h4>Numbers</h4>
                        <div class="ref-items">
                            <div class="ref-item"><code>‚Ä¢‚Äî‚Äî‚Äî‚Äî</code> = 1</div>
                            <div class="ref-item"><code>‚Ä¢‚Ä¢‚Äî‚Äî‚Äî</code> = 2</div>
                            <div class="ref-item"><code>‚Ä¢‚Ä¢‚Ä¢‚Äî‚Äî</code> = 3</div>
                            <div class="ref-item"><code>‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Äî</code> = 4</div>
                            <div class="ref-item"><code>‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</code> = 5</div>
                            <div class="ref-item"><code>‚Äî‚Ä¢‚Ä¢‚Ä¢‚Ä¢</code> = 6</div>
                            <div class="ref-item"><code>‚Äî‚Äî‚Ä¢‚Ä¢‚Ä¢</code> = 7</div>
                            <div class="ref-item"><code>‚Äî‚Äî‚Äî‚Ä¢‚Ä¢</code> = 8</div>
                            <div class="ref-item"><code>‚Äî‚Äî‚Äî‚Äî‚Ä¢</code> = 9</div>
                            <div class="ref-item"><code>‚Äî‚Äî‚Äî‚Äî‚Äî</code> = 0</div>
                        </div>
                    </div>
                    <div class="ref-section">
                        <h4>Special</h4>
                        <div class="ref-items">
                            <div class="ref-item"><code>/</code> = Word Space</div>
                            <div class="ref-item"><code>‚Ä¢‚Äî‚Ä¢‚Äî‚Ä¢‚Äî</code> = Period (.)</div>
                            <div class="ref-item"><code>‚Äî‚Äî‚Ä¢‚Ä¢‚Äî‚Äî</code> = Comma (,)</div>
                            <div class="ref-item"><code>‚Ä¢‚Ä¢‚Äî‚Äî‚Ä¢‚Ä¢</code> = Question (?)</div>
                            <div class="ref-item"><code>‚Ä¢‚Äî‚Äî‚Ä¢‚Ä¢‚Äî</code> = Exclamation (!)</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: rgba(59, 130, 246, 0.1); border-radius: 6px;">
                    <h4 style="margin-top: 0;">üí° Timing Guide:</h4>
                    <ul style="margin-bottom: 0;">
                        <li><strong>Dot:</strong> Quick blink (less than 200ms)</li>
                        <li><strong>Dash:</strong> Long blink (600ms or more)</li>
                        <li><strong>Letter gap:</strong> 1 second pause between letters</li>
                        <li><strong>Word gap:</strong> 2 seconds pause between words</li>
                    </ul>
                </div>
            </div>
        </section>
    </main>

    <script>
        // Enhanced device detection and UI updates
        document.addEventListener('DOMContentLoaded', () => {
            updateDeviceCapabilities();
            showMobileInstructions();
        });
        
        function updateDeviceCapabilities() {
            const capabilityList = document.getElementById('capabilityList');
            const bluetoothInstructions = document.getElementById('bluetoothInstructions');
            
            if (!capabilityList) return;
            
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const hasSerial = 'serial' in navigator;
            const hasBluetooth = 'bluetooth' in navigator;
            const isChrome = /Chrome/.test(navigator.userAgent);
            
            let capabilities = [];
            
            if (isMobile) {
                if (hasBluetooth && isChrome) {
                    capabilities.push('‚úÖ Bluetooth (Primary for mobile)');
                    if (bluetoothInstructions) {
                        bluetoothInstructions.style.display = 'block';
                    }
                } else if (!isChrome) {
                    capabilities.push('‚ùå Bluetooth (Chrome required)');
                } else {
                    capabilities.push('‚ùå Bluetooth (Not supported)');
                }
            } else {
                if (hasSerial) {
                    capabilities.push('‚úÖ Serial/USB (Primary for desktop)');
                } else {
                    capabilities.push('‚ùå Serial (Not supported)');
                }
                
                if (hasBluetooth) {
                    capabilities.push('‚úÖ Bluetooth (Available)');
                } else {
                    capabilities.push('‚ùå Bluetooth (Not supported)');
                }
            }
            
            capabilityList.innerHTML = capabilities.join('<br>');
        }
        
        function showMobileInstructions() {
            const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const bluetoothInstructions = document.getElementById('bluetoothInstructions');
            
            if (isMobile && bluetoothInstructions) {
                bluetoothInstructions.style.display = 'block';
            }
        }
    </script>

    <script src="morse.js"></script>
    <script src="storage.js"></script>
    <script>
        // Load the enhanced communication script
        const script = document.createElement('script');
        script.textContent = `
// Enhanced Communication Logic with Bluetooth Support

let serialPort = null;
let bluetoothDevice = null;
let bluetoothCharacteristic = null;
let reader = null;
let keepReading = false;
let currentBuilding = '';
let decodedText = '';
let isConnected = false;
let connectionType = null;

// UI elements
let liveMorseEl, buildingEl, decodedEl, statusEl, connectionStatusEl;
let connectBtn, disconnectBtn, saveBtn, translateBtn, speakBtn, clearBtn;
let manualBoxEl, wordCountEl, charCountEl;

// Bluetooth configuration
const BLUETOOTH_SERVICE_UUID = '12345678-1234-1234-1234-123456789abc';
const BLUETOOTH_CHARACTERISTIC_UUID = '87654321-4321-4321-4321-cba987654321';

document.addEventListener('DOMContentLoaded', () => {
    initializePage();
    setupEventListeners();
    applySettings();
    updateConnectionStatus();
    detectConnectionMethod();
});

function detectConnectionMethod() {
    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const hasSerial = 'serial' in navigator;
    const hasBluetooth = 'bluetooth' in navigator;
    
    console.log('Device detection:', { isMobile, hasSerial, hasBluetooth });
    updateConnectionUI(isMobile, hasSerial, hasBluetooth);
}

function updateConnectionUI(isMobile, hasSerial, hasBluetooth) {
    const connectBtn = document.getElementById('connectSerialBtn');
    
    if (!connectBtn) return;
    
    if (isMobile && hasBluetooth) {
        connectBtn.innerHTML = '<span>üì±</span> Connect Bluetooth';
        connectBtn.title = 'Connect via Bluetooth (Mobile)';
    } else if (hasSerial) {
        connectBtn.innerHTML = '<span>üîå</span> Connect Serial';
        connectBtn.title = 'Connect via Serial Port (Desktop)';
    } else {
        connectBtn.innerHTML = '<span>‚ùå</span> Not Supported';
        connectBtn.disabled = true;
        connectBtn.title = 'Connection not supported on this device/browser';
        showToast('Connection not supported. Use Chrome on Desktop or Android.', 'error', 5000);
    }
}

function initializePage() {
    liveMorseEl = document.getElementById('liveMorse');
    buildingEl = document.getElementById('building');
    decodedEl = document.getElementById('decoded');
    statusEl = document.getElementById('statusText');
    connectionStatusEl = document.getElementById('connectionStatus');
    
    connectBtn = document.getElementById('connectSerialBtn');
    disconnectBtn = document.getElementById('disconnectSerialBtn');
    saveBtn = document.getElementById('saveBtn');
    translateBtn = document.getElementById('translateBtn');
    speakBtn = document.getElementById('speakBtn');
    clearBtn = document.getElementById('clearBtn');
    
    manualBoxEl = document.getElementById('manualBox');
    wordCountEl = document.getElementById('wordCount');
    charCountEl = document.getElementById('charCount');
    
    updateDecoded();
    updateBuilding('‚Äî');
    
    const settings = getSettings() || {};
    if (settings.autoConnect) {
        setTimeout(() => {
            if (confirm('Auto-connect is enabled. Connect to device now?')) {
                connectDevice();
            }
        }, 1000);
    }
    
    showToast('Communication page loaded', 'info', 2000);
}

function setupEventListeners() {
    connectBtn?.addEventListener('click', connectDevice);
    disconnectBtn?.addEventListener('click', disconnectDevice);
    
    saveBtn?.addEventListener('click', saveCurrentMessage);
    translateBtn?.addEventListener('click', translateCurrentMessage);
    speakBtn?.addEventListener('click', speakCurrentMessage);
    clearBtn?.addEventListener('click', clearCurrentMessage);
    
    document.getElementById('mClear')?.addEventListener('click', clearManualInput);
    document.getElementById('mSend')?.addEventListener('click', addManualInput);
    document.getElementById('testBtn')?.addEventListener('click', testConnection);
    
    document.querySelectorAll('.morse-btn[data-ch]').forEach(btn => {
        btn.addEventListener('click', () => {
            const char = btn.getAttribute('data-ch');
            addToManualInput(char);
        });
    });
    
    document.getElementById('toggleQuickRef')?.addEventListener('click', toggleQuickReference);
    
    if (decodedEl) {
        decodedEl.addEventListener('input', debounce(updateWordCount, 300));
        decodedEl.addEventListener('paste', () => {
            setTimeout(updateWordCount, 100);
        });
    }
    
    if (manualBoxEl) {
        manualBoxEl.addEventListener('input', validateManualInput);
    }
}

async function connectDevice() {
    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const hasSerial = 'serial' in navigator;
    const hasBluetooth = 'bluetooth' in navigator;
    
    if (isMobile && hasBluetooth) {
        await connectBluetooth();
    } else if (hasSerial) {
        await connectSerial();
    } else {
        showToast('No supported connection method available', 'error', 3000);
    }
}

async function connectBluetooth() {
    if (!('bluetooth' in navigator)) {
        showToast('Web Bluetooth API not supported on this browser', 'error', 3000);
        return;
    }
    
    try {
        showToast('Searching for Bluetooth devices...', 'info', 2000);
        
        bluetoothDevice = await navigator.bluetooth.requestDevice({
            filters: [
                { namePrefix: 'EyeBlink' },
                { namePrefix: 'ESP32' },
                { namePrefix: 'Arduino' },
                { namePrefix: 'HC-' }
            ],
            optionalServices: [
                '0000ffe0-0000-1000-8000-00805f9b34fb',
                BLUETOOTH_SERVICE_UUID,
                'battery_service',
                'device_information'
            ]
        });
        
        console.log('Selected device:', bluetoothDevice.name);
        
        const server = await bluetoothDevice.gatt.connect();
        console.log('Connected to GATT server');
        
        let service;
        try {
            service = await server.getPrimaryService(BLUETOOTH_SERVICE_UUID);
            console.log('Using custom service');
        } catch (e) {
            try {
                service = await server.getPrimaryService('0000ffe0-0000-1000-8000-00805f9b34fb');
                console.log('Using standard serial service');
            } catch (e2) {
                throw new Error('No compatible service found on device');
            }
        }
        
        try {
            bluetoothCharacteristic = await service.getCharacteristic(BLUETOOTH_CHARACTERISTIC_UUID);
        } catch (e) {
            try {
                bluetoothCharacteristic = await service.getCharacteristic('0000ffe1-0000-1000-8000-00805f9b34fb');
            } catch (e2) {
                throw new Error('No compatible characteristic found');
            }
        }
        
        await bluetoothCharacteristic.startNotifications();
        bluetoothCharacteristic.addEventListener('characteristicvaluechanged', handleBluetoothData);
        bluetoothDevice.addEventListener('gattserverdisconnected', handleBluetoothDisconnection);
        
        isConnected = true;
        connectionType = 'bluetooth';
        updateConnectionStatus();
        
        localStorage.setItem('device_connected', 'true');
        localStorage.setItem('connection_type', 'bluetooth');
        updateSessionConnection(true);
        
        showToast('Bluetooth connected: ' + bluetoothDevice.name, 'success', 3000);
        
    } catch (error) {
        console.error('Bluetooth connection failed:', error);
        
        let errorMessage = 'Bluetooth connection failed';
        if (error.message.includes('User cancelled')) {
            errorMessage = 'Connection cancelled by user';
        } else if (error.message.includes('No compatible')) {
            errorMessage = 'Device not compatible. Make sure your ESP32 has the correct Bluetooth service.';
        } else {
            errorMessage = 'Bluetooth error: ' + error.message;
        }
        
        showToast(errorMessage, 'error', 4000);
        isConnected = false;
        connectionType = null;
        updateConnectionStatus();
        localStorage.setItem('device_connected', 'false');
    }
}

async function connectSerial() {
    if (!('serial' in navigator)) {
        showToast('Web Serial API not available. Please use Chrome or Edge browser.', 'error', 3000);
        return;
    }
    
    try {
        showToast('Selecting serial port...', 'info', 2000);
        
        serialPort = await navigator.serial.requestPort();
        await serialPort.open({ 
            baudRate: 115200,
            dataBits: 8,
            stopBits: 1,
            parity: 'none',
            flowControl: 'none'
        });
        
        isConnected = true;
        connectionType = 'serial';
        updateConnectionStatus();
        
        localStorage.setItem('device_connected', 'true');
        localStorage.setItem('connection_type', 'serial');
        updateSessionConnection(true);
        
        keepReading = true;
        readSerialData();
        
        showToast('Serial device connected successfully!', 'success', 3000);
        
    } catch (error) {
        console.error('Serial connection failed:', error);
        
        let errorMessage = 'Serial connection failed';
        if (error.message.includes('No port selected')) {
            errorMessage = 'No device selected';
        } else {
            errorMessage = 'Serial error: ' + error.message;
        }
        
        showToast(errorMessage, 'error', 3000);
        isConnected = false;
        connectionType = null;
        updateConnectionStatus();
        localStorage.setItem('device_connected', 'false');
    }
}

function handleBluetoothData(event) {
    const value = event.target.value;
    const decoder = new TextDecoder('utf-8');
    const data = decoder.decode(value);
    
    console.log('Bluetooth data received:', data);
    
    const lines = data.split('\\n');
    lines.forEach(line => {
        const trimmedLine = line.trim();
        if (trimmedLine) {
            handleDataLine(trimmedLine);
        }
    });
}

function handleBluetoothDisconnection() {
    console.log('Bluetooth device disconnected');
    isConnected = false;
    connectionType = null;
    bluetoothDevice = null;
    bluetoothCharacteristic = null;
    
    updateConnectionStatus();
    localStorage.setItem('device_connected', 'false');
    updateSessionConnection(false);
    
    showToast('Bluetooth device disconnected', 'warning', 3000);
}

async function disconnectDevice() {
    keepReading = false;
    
    if (connectionType === 'bluetooth' && bluetoothDevice) {
        try {
            if (bluetoothCharacteristic) {
                await bluetoothCharacteristic.stopNotifications();
                bluetoothCharacteristic.removeEventListener('characteristicvaluechanged', handleBluetoothData);
            }
            
            if (bluetoothDevice.gatt.connected) {
                bluetoothDevice.gatt.disconnect();
            }
        } catch (e) {
            console.error('Error disconnecting Bluetooth:', e);
        }
        bluetoothDevice = null;
        bluetoothCharacteristic = null;
        
    } else if (connectionType === 'serial' && serialPort) {
        try {
            if (reader) {
                await reader.cancel();
                reader = null;
            }
            await serialPort.close();
        } catch (e) {
            console.error('Error disconnecting Serial:', e);
        }
        serialPort = null;
    }
    
    isConnected = false;
    connectionType = null;
    updateConnectionStatus();
    
    localStorage.setItem('device_connected', 'false');
    localStorage.removeItem('connection_type');
    updateSessionConnection(false);
    
    showToast('Device disconnected', 'info', 2000);
}

async function readSerialData() {
    if (!serialPort) return;
    
    try {
        const textDecoder = new TextDecoderStream();
        const readableStreamClosed = serialPort.readable.pipeTo(textDecoder.writable);
        reader = textDecoder.readable
            .pipeThrough(new TransformStream(new LineBreakTransformer()))
            .getReader();
        
        while (keepReading) {
            const { value, done } = await reader.read();
            
            if (done) {
                reader.releaseLock();
                break;
            }
            
            if (value) {
                handleDataLine(value.trim());
            }
        }
        
    } catch (error) {
        console.error('Read error:', error);
        showToast('Communication error with device', 'error', 3000);
        
        if (isConnected) {
            disconnectDevice();
        }
    }
}

function handleDataLine(line) {
    if (!line) return;
    
    console.log('Received:', line);
    
    if (liveMorseEl) {
        liveMorseEl.textContent = line;
    }
    
    if (line === '/' || line === 'SPACE' || line === 'WORD_END') {
        if (currentBuilding) {
            const decoded = decodeMorse(currentBuilding);
            if (decoded && decoded !== '?') {
                decodedText += decoded;
            }
        }
        decodedText += ' ';
        currentBuilding = '';
        updateBuilding('‚Äî');
    } else if (line === '|' || line === 'LETTER' || line === 'LETTER_END') {
        if (currentBuilding) {
            const decoded = decodeMorse(currentBuilding);
            if (decoded && decoded !== '?') {
                decodedText += decoded;
            }
        }
        currentBuilding = '';
        updateBuilding('‚Äî');
    } else if (isValidMorse(line)) {
        const decoded = decodeMorse(line);
        if (decoded && decoded !== '?') {
            decodedText += decoded;
        }
        currentBuilding = line;
        updateBuilding(line);
    } else if (line.match(/^[.\\-]+$/)) {
        currentBuilding = line;
        updateBuilding(line);
    } else if (line.startsWith('BLINK:') || line.startsWith('MORSE:')) {
        const morseData = line.split(':')[1]?.trim();
        if (morseData) {
            currentBuilding = morseData;
            updateBuilding(morseData);
        }
    } else if (line.startsWith('BUILDING:')) {
        const pattern = line.split(':')[1]?.trim();
        if (pattern) {
            currentBuilding = pattern;
            updateBuilding(pattern);
        }
    } else {
        console.log('Raw data:', line);
        
        if (line.includes('.') || line.includes('-')) {
            const morseMatch = line.match(/([.\\-\\s/]+)/);
            if (morseMatch) {
                currentBuilding = morseMatch[1].trim();
                updateBuilding(currentBuilding);
            }
        }
    }
    
    updateDecoded();
    
    const settings = getSettings() || {};
    if (settings.autoSave && decodedText.length > 0) {
        if (decodedText.length % 10 === 0) {
            saveCurrentMessage(true);
        }
    }
}

function updateSessionConnection(connected) {
    try {
        const session = getCurrentSession();
        session.deviceConnected = connected;
        session.connectionType = connectionType;
        
        if (typeof storage !== 'undefined' && storage.set) {
            storage.set('eyeblink_session_v2', session);
        } else {
            localStorage.setItem('eyeblink_session_v2', JSON.stringify(session));
        }
    } catch (error) {
        console.error('Error updating session:', error);
    }
}

function updateBuilding(pattern) {
    const buildingText = buildingEl?.querySelector('.building-text');
    if (buildingText) {
        buildingText.textContent = pattern || '‚Äî';
    }
    
    if (buildingEl) {
        buildingEl.classList.remove('building-dot', 'building-dash', 'active');
        
        if (pattern && pattern !== '‚Äî') {
            buildingEl.classList.add('active');
            
            if (pattern.includes('.') && !pattern.includes('-')) {
                buildingEl.classList.add('building-dot');
            } else if (pattern.includes('-') && !pattern.includes('.')) {
                buildingEl.classList.add('building-dash');
            }
        }
    }
}

function updateDecoded() {
    if (decodedEl) {
        decodedEl.textContent = decodedText;
    }
    updateWordCount();
}

function updateWordCount() {
    const text = decodedEl ? decodedEl.textContent : decodedText;
    const stats = getTextStatistics(text);
    
    if (wordCountEl) wordCountEl.textContent = stats.words;
    if (charCountEl) charCountEl.textContent = stats.characters;
}

function updateConnectionStatus() {
    const indicator = document.querySelector('.status-indicator');
    const connectionTypeEl = document.getElementById('connectionType');
    
    if (isConnected) {
        statusEl.textContent = 'Connected (' + connectionType + ')';
        indicator?.classList.remove('offline');
        indicator?.classList.add('online');
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
        
        if (connectionTypeEl) {
            connectionTypeEl.textContent = connectionType.toUpperCase();
            connectionTypeEl.className = 'connection-type ' + connectionType;
            connectionTypeEl.style.display = 'inline-block';
        }
        
        const deviceInfo = document.getElementById('deviceInfo');
        if (deviceInfo) {
            deviceInfo.style.display = 'block';
            const portName = document.getElementById('portName');
            const connectionMethod = document.getElementById('connectionMethod');
            if (portName) {
                const deviceName = bluetoothDevice?.name || 'Serial Device';
                portName.textContent = deviceName;
            }
            if (connectionMethod) {
                connectionMethod.textContent = connectionType === 'bluetooth' ? 'Bluetooth LE' : 'Serial USB';
            }
        }
        
        const deviceStatusText = document.getElementById('deviceStatusText');
        if (deviceStatusText) {
            deviceStatusText.textContent = 'Ready and listening';
        }
        
        // Enable test button
        const testBtn = document.getElementById('testBtn');
        if (testBtn) testBtn.disabled = false;
        
    } else {
        statusEl.textContent = 'Disconnected';
        indicator?.classList.remove('online');
        indicator?.classList.add('offline');
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        
        if (connectionTypeEl) {
            connectionTypeEl.style.display = 'none';
        }
        
        const deviceInfo = document.getElementById('deviceInfo');
        if (deviceInfo) {
            deviceInfo.style.display = 'none';
        }
        
        // Disable test button
        const testBtn = document.getElementById('testBtn');
        if (testBtn) testBtn.disabled = true;
    }
}

function saveCurrentMessage(silent = false) {
    const text = decodedText.trim();
    
    if (!text) {
        if (!silent) showToast('No text to save', 'warning', 2000);
        return;
    }
    
    try {
        if (typeof saveMessage === 'function') {
            const messageId = saveMessage(text, false, 'en');
            if (!silent) {
                showToast('Message saved successfully!', 'success', 2000);
            }
        } else {
            const messages = JSON.parse(localStorage.getItem('eyeblink_messages_v2') || '[]');
            const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const stats = getTextStatistics(text);
            
            messages.unshift({
                id: messageId,
                text: text,
                originalText: text,
                translated: false,
                language: 'en',
                timestamp: Date.now(),
                date: new Date().toLocaleString(),
                stats: stats
            });
            
            if (messages.length > 100) {
                messages.splice(100);
            }
            
            localStorage.setItem('eyeblink_messages_v2', JSON.stringify(messages));
            
            if (!silent) {
                showToast('Message saved successfully!', 'success', 2000);
            }
        }
        
        setTimeout(updateWordCount, 100);
        
    } catch (error) {
        console.error('Save error:', error);
        if (!silent) {
            showToast('Failed to save message: ' + error.message, 'error', 3000);
        }
    }
}

async function translateCurrentMessage() {
    const text = decodedText.trim();
    
    if (!text) {
        showToast('No text to translate', 'warning', 2000);
        return;
    }
    
    const settings = getSettings() || {};
    const targetLang = settings.targetLanguage || 'bn';
    
    try {
        showToast('Translating...', 'info', 2000);
        
        const response = await fetch('https://libretranslate.de/translate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                q: text,
                source: 'en',
                target: targetLang,
                format: 'text'
            })
        });
        
        if (!response.ok) {
            throw new Error('Translation service error: ' + response.status);
        }
        
        const result = await response.json();
        
        if (result.translatedText) {
            alert('Original: ' + text + '\\n\\nTranslated to ' + targetLang.toUpperCase() + ':\\n' + result.translatedText);
            
            const saveTranslation = confirm('Save translated version?');
            
            if (saveTranslation) {
                try {
                    if (typeof saveMessage === 'function') {
                        saveMessage(result.translatedText, true, targetLang);
                    } else {
                        const messages = JSON.parse(localStorage.getItem('eyeblink_messages_v2') || '[]');
                        const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        const stats = getTextStatistics(result.translatedText);
                        
                        messages.unshift({
                            id: messageId,
                            text: result.translatedText,
                            originalText: text,
                            translated: true,
                            language: targetLang,
                            timestamp: Date.now(),
                            date: new Date().toLocaleString(),
                            stats: stats
                        });
                        
                        localStorage.setItem('eyeblink_messages_v2', JSON.stringify(messages));
                    }
                    
                    showToast('Translated message saved!', 'success', 3000);
                } catch (saveError) {
                    console.error('Save translation error:', saveError);
                    showToast('Translation succeeded but save failed', 'warning', 3000);
                }
            }
        } else {
            throw new Error('No translation received from service');
        }
        
    } catch (error) {
        console.error('Translation error:', error);
        
        if (error.message.includes('Failed to fetch')) {
            showToast('Translation failed: Network error. Check internet connection.', 'error', 4000);
        } else if (error.message.includes('503') || error.message.includes('502')) {
            showToast('Translation service temporarily unavailable. Try again later.', 'error', 4000);
        } else {
            showToast('Translation failed: ' + error.message, 'error', 4000);
        }
        
        const fallbackTranslate = confirm('Translation service failed. Copy text to translate manually?\\n\\nText: ' + text);
        if (fallbackTranslate) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Text copied to clipboard', 'success', 2000);
            }).catch(() => {
                showToast('Could not copy text', 'error', 2000);
            });
        }
    }
}

function speakCurrentMessage() {
    const text = decodedText.trim();
    
    if (!text) {
        showToast('No text to speak', 'warning', 2000);
        return;
    }
    
    if (!('speechSynthesis' in window)) {
        showToast('Speech synthesis not supported', 'error', 3000);
        return;
    }
    
    try {
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        const settings = getSettings() || {};
        
        utterance.rate = settings.speechSpeed || 1.0;
        utterance.pitch = settings.voicePitch || 1.0;
        utterance.volume = 1.0;
        
        const voices = speechSynthesis.getVoices();
        const genderPref = settings.voiceGender || 'female';
        
        let selectedVoice = voices.find(voice => 
            voice.name.toLowerCase().includes(genderPref) ||
            voice.name.toLowerCase().includes('female') && genderPref === 'female' ||
            voice.name.toLowerCase().includes('male') && genderPref === 'male'
        );
        
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.default) || voices[0];
        }
        
        if (selectedVoice) {
            utterance.voice = selectedVoice;
        }
        
        utterance.onstart = () => showToast('Speaking...', 'info', 1000);
        utterance.onend = () => showToast('Speech completed', 'success', 2000);
        utterance.onerror = (event) => {
            console.error('Speech error:', event.error);
            showToast('Speech failed', 'error', 2000);
        };
        
        speechSynthesis.speak(utterance);
        
    } catch (error) {
        console.error('Speech error:', error);
        showToast('Speech failed', 'error', 3000);
    }
}

function clearCurrentMessage() {
    if (decodedText && !confirm('Clear current message?')) {
        return;
    }
    
    decodedText = '';
    currentBuilding = '';
    updateDecoded();
    updateBuilding('‚Äî');
    
    if (liveMorseEl) liveMorseEl.textContent = '(waiting for input)';
    
    showToast('Message cleared', 'info', 1500);
}

function addToManualInput(char) {
    if (!manualBoxEl) return;
    
    const current = manualBoxEl.textContent || '';
    
    if (char === ' ') {
        manualBoxEl.textContent = current + ' ';
    } else {
        manualBoxEl.textContent = (current + ' ' + char).trim();
    }
    
    manualBoxEl.focus();
    const range = document.createRange();
    range.selectNodeContents(manualBoxEl);
    range.collapse(false);
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
}

function clearManualInput() {
    if (manualBoxEl) {
        manualBoxEl.textContent = '';
        manualBoxEl.focus();
    }
}

function addManualInput() {
    if (!manualBoxEl) return;
    
    const manualText = manualBoxEl.textContent.trim();
    if (!manualText) return;
    
    const tokens = manualText.split(/\\s+/);
    let addedText = '';
    
    for (const token of tokens) {
        if (token === '/' || token === 'SPACE') {
            addedText += ' ';
        } else if (isValidMorse(token)) {
            const decoded = decodeMorse(token);
            addedText += decoded;
        }
    }
    
    if (addedText) {
        decodedText += addedText;
        updateDecoded();
        clearManualInput();
        showToast('Added: ' + addedText, 'success', 2000);
    } else {
        showToast('No valid Morse code found', 'warning', 2000);
    }
}

function validateManualInput() {
    if (!manualBoxEl) return;
    
    const text = manualBoxEl.textContent;
    const isValid = !text || isValidMorse(text) || text.includes('/') || text.includes('SPACE');
    
    if (isValid) {
        manualBoxEl.style.borderColor = '';
        manualBoxEl.style.background = '';
    } else {
        manualBoxEl.style.borderColor = 'var(--danger)';
        manualBoxEl.style.background = 'rgba(239, 68, 68, 0.1)';
    }
}

function toggleQuickReference() {
    const content = document.getElementById('quickRefContent');
    const button = document.getElementById('toggleQuickRef');
    
    if (content && button) {
        const isVisible = content.style.display !== 'none';
        content.style.display = isVisible ? 'none' : 'block';
        button.textContent = isVisible ? 'Show Chart' : 'Hide Chart';
    }
}

function applySettings() {
    const settings = getSettings() || {};
    
    if (settings.theme === 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark');
    }
    
    if (settings.fontSize) {
        document.body.className = (document.body.className || '').replace(/font-\\w+/g, '') + ' font-' + settings.fontSize;
    }
}

async function sendToDevice(data) {
    if (!isConnected) {
        showToast('Device not connected', 'error', 2000);
        return false;
    }
    
    try {
        if (connectionType === 'bluetooth' && bluetoothCharacteristic) {
            const encoder = new TextEncoder();
            const dataWithNewline = data + '\\n';
            await bluetoothCharacteristic.writeValue(encoder.encode(dataWithNewline));
            console.log('Sent via Bluetooth:', data);
            return true;
            
        } else if (connectionType === 'serial' && serialPort) {
            const writer = serialPort.writable.getWriter();
            const encoder = new TextEncoder();
            await writer.write(encoder.encode(data + '\\n'));
            writer.releaseLock();
            console.log('Sent via Serial:', data);
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('Send error:', error);
        showToast('Failed to send data to device', 'error', 2000);
        return false;
    }
}

async function testConnection() {
    if (!isConnected) {
        showToast('Device not connected', 'error', 2000);
        return;
    }
    
    showToast('Testing connection...', 'info', 1000);
    const success = await sendToDevice('TEST');
    
    if (success) {
        showToast('Connection test sent', 'success', 2000);
    }
}

class LineBreakTransformer {
    constructor() {
        this.chunks = '';
    }
    
    transform(chunk, controller) {
        this.chunks += chunk;
        const lines = this.chunks.split('\\n');
        this.chunks = lines.pop() || '';
        
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed) {
                controller.enqueue(trimmed);
            }
        }
    }
    
    flush(controller) {
        const trimmed = this.chunks.trim();
        if (trimmed) {
            controller.enqueue(trimmed);
        }
    }
}

function getSettings() {
    try {
        return JSON.parse(localStorage.getItem('eyeblink_settings_v2') || '{}');
    } catch {
        return {};
    }
}

function getTextStatistics(text) {
    if (!text || typeof text !== 'string') {
        return { characters: 0, words: 0, sentences: 0 };
    }
    
    const characters = text.length;
    const words = text.trim() ? text.trim().split(/\\s+/).length : 0;
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0).length;
    
    return { characters, words, sentences };
}

function getCurrentSession() {
    try {
        if (typeof storage !== 'undefined' && storage.get) {
            return storage.get('eyeblink_session_v2', {
                startTime: Date.now(),
                deviceConnected: false
            });
        } else {
            const session = localStorage.getItem('eyeblink_session_v2');
            return session ? JSON.parse(session) : {
                startTime: Date.now(),
                deviceConnected: false
            };
        }
    } catch (error) {
        console.error('Error getting session:', error);
        return {
            startTime: Date.now(),
            deviceConnected: false
        };
    }
}

const MORSE_CODE_MAP = {
    ".-": "A", "-...": "B", "-.-.": "C", "-..": "D", ".": "E",
    "..-.": "F", "--.": "G", "....": "H", "..": "I", ".---": "J",
    "-.-": "K", ".-..": "L", "--": "M", "-.": "N", "---": "O",
    ".--.": "P", "--.-": "Q", ".-.": "R", "...": "S", "-": "T",
    "..-": "U", "...-": "V", ".--": "W", "-..-": "X", "-.--": "Y",
    "--..": "Z", "-----": "0", ".----": "1", "..---": "2", "...--": "3", 
    "....-": "4", ".....": "5", "-....": "6", "--...": "7", "---..": "8", "----.": "9"
};

function isValidMorse(morse) {
    if (!morse || typeof morse !== 'string') return false;
    return /^[.\\-\\s/]+$/.test(morse);
}

function decodeMorse(morse) {
    if (!morse || typeof morse !== 'string') return '';
    
    if (morse === '/' || morse === ' / ' || morse.trim() === '/') {
        return ' ';
    }
    
    const cleanMorse = morse.trim().replace(/\\s+/g, ' ');
    const letters = cleanMorse.split(' ').filter(letter => letter.length > 0);
    
    return letters.map(letter => {
        if (letter === '/') return ' ';
        return MORSE_CODE_MAP[letter] || '?';
    }).join('');
}

function showToast(message, type = 'info', duration = 3000) {
    console.log('[' + type.toUpperCase() + '] ' + message);
    
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = 
        'position: fixed;' +
        'top: 20px;' +
        'right: 20px;' +
        'background: ' + (type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : type === 'warning' ? '#f59e0b' : '#3b82f6') + ';' +
        'color: white;' +
        'padding: 12px 20px;' +
        'border-radius: 6px;' +
        'z-index: 1000;' +
        'font-family: system-ui, -apple-system, sans-serif;' +
        'box-shadow: 0 4px 12px rgba(0,0,0,0.15);' +
        'max-width: 300px;' +
        'word-wrap: break-word;';
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
        if (toast.parentNode) {
            toast.remove();
        }
    }, duration);
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

window.addEventListener('beforeunload', async () => {
    if (isConnected) {
        await disconnectDevice();
    }
});

document.addEventListener('visibilitychange', () => {
    if (document.hidden && isConnected) {
        const settings = getSettings();
        if (settings.disconnectOnHidden) {
            disconnectDevice();
        }
    }
});
`;
        document.head.appendChild(script);
    </script>
</body>
</html>